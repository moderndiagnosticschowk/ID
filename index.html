<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Manager</title>
    <link rel="stylesheet" href="styles.css">
</head>
    <style>
        /* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f5f7fa;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
.header {
    background: #fff;
    padding: 1rem 2rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
}

.header h1 {
    color: #2c3e50;
    font-weight: 600;
}

.header-controls {
    display: flex;
    gap: 0.5rem;
}

/* Buttons */
.btn {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
}

/* File count display */
.file-count {
    background: #f0f9ff;
    color: #1e40af;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-weight: 600;
    font-size: 0.9rem;
    border: 2px solid #3b82f6;
}

.btn-primary {
    background: #10b981;
    color: white;
}

.btn-primary:hover {
    background: #059669;
    transform: translateY(-1px);
}

.btn-secondary {
    background: #6b7280;
    color: white;
}

.btn-secondary:hover {
    background: #4b5563;
    transform: translateY(-1px);
}

.btn-danger {
    background: #ef4444;
    color: white;
    padding: 0.25rem 0.5rem;
    font-size: 0.8rem;
}

.btn-danger:hover {
    background: #dc2626;
}

.btn-outline {
    background: transparent;
    border: 1px solid #d1d5db;
    color: #374151;
    padding: 0.25rem 0.5rem;
    font-size: 0.8rem;
}

.btn-outline:hover {
    background: #f9fafb;
    border-color: #9ca3af;
}

/* Main Content */
.main {
    flex: 1;
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
}

/* Upload Section */
.upload-section {
    margin-bottom: 3rem;
}

.drop-zone {
    border: 2px dashed #d1d5db;
    border-radius: 12px;
    padding: 3rem 2rem;
    text-align: center;
    background: #fff;
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
}

.drop-zone:hover,
.drop-zone.dragover {
    border-color: #3b82f6;
    background: #f0f9ff;
    transform: translateY(-2px);
}

.drop-content h3 {
    margin: 1rem 0 0.5rem;
    color: #374151;
    font-weight: 600;
}

.drop-content p {
    color: #6b7280;
    font-size: 0.9rem;
}

.upload-icon {
    width: 48px;
    height: 48px;
    color: #9ca3af;
    margin: 0 auto;
}

/* Upload Progress */
.upload-progress {
    margin-top: 1rem;
    padding: 1rem;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: #e5e7eb;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.progress-fill {
    height: 100%;
    background: #3b82f6;
    border-radius: 4px;
    transition: width 0.3s ease;
    width: 0%;
}

#progress-text {
    font-size: 0.9rem;
    color: #6b7280;
}

/* File List Section */
.file-list-section h2 {
    margin-bottom: 1.5rem;
    color: #2c3e50;
    font-weight: 600;
}

.table-container {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    overflow: hidden;
}

.file-table {
    width: 100%;
    border-collapse: collapse;
}

.file-table th,
.file-table td {
    padding: 1rem;
    text-align: left;
    border-bottom: 1px solid #e5e7eb;
}

.file-table th {
    background: #f9fafb;
    font-weight: 600;
    color: #374151;
    font-size: 0.9rem;
}

.file-table tbody tr:hover {
    background: #f9fafb;
}

.file-table td {
    font-size: 0.9rem;
}

.file-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.empty-state {
    padding: 3rem 2rem;
    text-align: center;
    color: #6b7280;
}

/* Modal */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal-content {
    background: #fff;
    border-radius: 12px;
    max-width: 90vw;
    max-height: 90vh;
    width: 800px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 25px rgba(0,0,0,0.2);
}

.modal-header {
    padding: 1.5rem;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h3 {
    color: #2c3e50;
    font-weight: 600;
}

.modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #6b7280;
    padding: 0;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    background: #f3f4f6;
    color: #374151;
}

.modal-body {
    padding: 1.5rem;
    flex: 1;
    overflow: auto;
}

.preview-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 200px;
}

.preview-container img {
    max-width: 100%;
    max-height: 70vh;
    object-fit: contain;
    border-radius: 8px;
}

.preview-container iframe {
    width: 100%;
    height: 70vh;
    border: none;
    border-radius: 8px;
}

.preview-error {
    text-align: center;
    color: #6b7280;
    padding: 2rem;
}

/* Loading Overlay */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.9);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 3px solid #e5e7eb;
    border-top: 3px solid #3b82f6;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Footer */
.footer {
    background: #fff;
    padding: 1.5rem 2rem;
    text-align: center;
    color: #6b7280;
    font-size: 0.9rem;
    border-top: 1px solid #e5e7eb;
}

/* Utility Classes */
.hidden {
    display: none !important;
}

.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0,0,0,0);
    white-space: nowrap;
    border: 0;
}

/* Responsive Design */
@media (max-width: 768px) {
    .main {
        padding: 1rem;
    }
    
    .header {
        padding: 1rem;
        flex-direction: column;
        align-items: stretch;
    }
    
    .header-controls {
        justify-content: center;
    }
    
    .drop-zone {
        padding: 2rem 1rem;
    }
    
    .file-table {
        font-size: 0.8rem;
    }
    
    .file-table th,
    .file-table td {
        padding: 0.75rem 0.5rem;
    }
    
    .file-actions {
        flex-direction: column;
    }
    
    .modal-content {
        margin: 1rem;
        max-width: calc(100vw - 2rem);
        max-height: calc(100vh - 2rem);
    }
    
    .preview-container iframe {
        height: 50vh;
    }
}

@media (max-width: 480px) {
    .file-table thead {
        display: none;
    }
    
    .file-table,
    .file-table tbody,
    .file-table tr,
    .file-table td {
        display: block;
        width: 100%;
    }
    
    .file-table tr {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        margin-bottom: 1rem;
        padding: 1rem;
        background: #fff;
    }
    
    .file-table td {
        border: none;
        padding: 0.25rem 0;
        position: relative;
        padding-left: 30%;
    }
    
    .file-table td:before {
        content: attr(data-label) ": ";
        position: absolute;
        left: 0;
        width: 25%;
        font-weight: 600;
        color: #374151;
    }
}
    </style>
<body>
    <!-- Header -->
    <header class="header">
        <h1>üåê Public File Sharing</h1>
        <div class="header-controls">
            <span class="file-count">Total Files: <span id="total-files">0</span></span>
            <button id="refresh-btn" class="btn btn-primary">üîÑ Refresh</button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Upload Area -->
        <section class="upload-section">
            <div id="drop-zone" class="drop-zone">
                <div class="drop-content">
                    <svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
                    </svg>
                    <h3>Upload & Share Files Publicly</h3>
                    <p>Anyone can upload and download files from here</p>
                </div>
                <input type="file" id="file-input" multiple hidden>
            </div>
            
            <!-- Upload Progress -->
            <div id="upload-progress" class="upload-progress hidden">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <span id="progress-text">Uploading... 0%</span>
            </div>
        </section>

        <!-- File List -->
        <section class="file-list-section">
            <h2>üìÅ Public Files (Everyone can see & download)</h2>
            <div class="table-container">
                <table id="file-table" class="file-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Size</th>
                            <th>Type</th>
                            <th>Uploader</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="file-table-body">
                        <!-- Files will be inserted here -->
                    </tbody>
                </table>
                <div id="empty-state" class="empty-state">
                    <p>üöÄ No public files yet. Be the first to upload and share!</p>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <p>üåç Public File Sharing Platform - Upload anything, Share everything! | Built with ‚ù§Ô∏è</p>
    </footer>

    <!-- Preview Modal -->
    <div id="preview-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title">File Preview</h3>
                <button id="modal-close" class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div id="preview-container" class="preview-container">
                    <!-- Preview content will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="spinner"></div>
        <p>Connecting to Google Drive...</p>
    </div>
    <script>
        // Public File Sharing Platform
class PublicFileManager {
    constructor() {
        this.files = [];
        this.maxFileSize = 100 * 1024 * 1024; // 100MB limit
        this.allowedTypes = []; // Allow all file types
        
        this.initializeElements();
        this.initializeEventListeners();
        this.initializeStorage();
        this.loadPublicFiles();
        this.updateFileCount();
    }

    initializeElements() {
        // Main elements
        this.dropZone = document.getElementById('drop-zone');
        this.fileInput = document.getElementById('file-input');
        this.uploadProgress = document.getElementById('upload-progress');
        this.progressFill = document.getElementById('progress-fill');
        this.progressText = document.getElementById('progress-text');
        this.fileTableBody = document.getElementById('file-table-body');
        this.emptyState = document.getElementById('empty-state');
        this.totalFilesSpan = document.getElementById('total-files');
        
        // Modal elements
        this.previewModal = document.getElementById('preview-modal');
        this.modalTitle = document.getElementById('modal-title');
        this.modalClose = document.getElementById('modal-close');
        this.previewContainer = document.getElementById('preview-container');
        
        // Control buttons
        this.refreshBtn = document.getElementById('refresh-btn');
    }

    initializeEventListeners() {
        // Drag and drop
        this.dropZone.addEventListener('dragover', this.handleDragOver.bind(this));
        this.dropZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.dropZone.addEventListener('drop', this.handleDrop.bind(this));
        this.dropZone.addEventListener('click', () => this.fileInput.click());
        
        // File input
        this.fileInput.addEventListener('change', this.handleFileSelect.bind(this));
        
        // Modal
        this.modalClose.addEventListener('click', this.closeModal.bind(this));
        this.previewModal.addEventListener('click', (e) => {
            if (e.target === this.previewModal) this.closeModal();
        });
        
        // Control buttons
        this.refreshBtn.addEventListener('click', this.refreshFiles.bind(this));
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') this.closeModal();
        });

        // Auto-refresh every 10 seconds to get new files from other users
        setInterval(() => {
            this.refreshFiles();
        }, 10000);
    }

    async initializeStorage() {
        // Use localStorage as global storage (simulating a server)
        // In real implementation, you'd use a proper backend/database
        console.log('üåê Public storage initialized');
    }

    async loadPublicFiles() {
        try {
            // Load from "global" localStorage (simulating server data)
            const publicFiles = localStorage.getItem('publicFileShare');
            this.files = publicFiles ? JSON.parse(publicFiles) : [];
            this.renderFileList();
            this.updateFileCount();
        } catch (error) {
            console.error('Failed to load public files:', error);
            this.files = [];
        }
    }

    async savePublicFiles() {
        try {
            // Save to "global" localStorage (simulating server save)
            localStorage.setItem('publicFileShare', JSON.stringify(this.files));
            console.log(`üíæ Saved ${this.files.length} public files`);
        } catch (error) {
            console.error('Failed to save public files:', error);
        }
    }

    refreshFiles() {
        console.log('üîÑ Refreshing public files...');
        this.loadPublicFiles();
    }

    updateFileCount() {
        this.totalFilesSpan.textContent = this.files.length;
    }

    handleDragOver(e) {
        e.preventDefault();
        this.dropZone.classList.add('dragover');
    }

    handleDragLeave(e) {
        e.preventDefault();
        if (!this.dropZone.contains(e.relatedTarget)) {
            this.dropZone.classList.remove('dragover');
        }
    }

    handleDrop(e) {
        e.preventDefault();
        this.dropZone.classList.remove('dragover');
        const files = Array.from(e.dataTransfer.files);
        this.processFiles(files);
    }

    handleFileSelect(e) {
        const files = Array.from(e.target.files);
        this.processFiles(files);
        this.fileInput.value = '';
    }

    async processFiles(files) {
        if (files.length === 0) return;

        this.showUploadProgress();

        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            // Check file size
            if (file.size > this.maxFileSize) {
                alert(`‚ùå File "${file.name}" is too large. Maximum size is 100MB.`);
                continue;
            }
            
            const progress = ((i + 1) / files.length) * 100;
            
            await this.uploadPublicFile(file);
            this.updateProgress(progress);
            
            // Simulate upload delay
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        this.hideUploadProgress();
        this.renderFileList();
        this.savePublicFiles();
        this.updateFileCount();
        
        // Show success message
        const uploadedCount = files.length;
        alert(`üéâ Successfully uploaded ${uploadedCount} file(s) to public storage!\n\n‚úÖ Everyone can now see and download your files.`);
    }

    async uploadPublicFile(file) {
        // Generate a random uploader name for demo
        const uploaderNames = ['Anonymous', 'User123', 'FileSharer', 'Guest', 'Contributor', 'Helper'];
        const randomUploader = uploaderNames[Math.floor(Math.random() * uploaderNames.length)];
        
        const fileData = {
            id: this.generateId(),
            name: file.name,
            size: file.size,
            type: file.type,
            uploadDate: new Date().toISOString(),
            uploader: randomUploader,
            data: null
        };

        try {
            // Store file data as base64 for public access
            const base64Data = await this.fileToBase64(file);
            fileData.data = base64Data;
            
            console.log(`üì§ Uploading "${file.name}" to public storage`);
        } catch (error) {
            console.error('Failed to process file:', error);
            fileData.data = null;
        }

        this.files.push(fileData);
    }

    fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });
    }

    showUploadProgress() {
        this.uploadProgress.classList.remove('hidden');
        this.updateProgress(0);
    }

    hideUploadProgress() {
        setTimeout(() => {
            this.uploadProgress.classList.add('hidden');
        }, 500);
    }

    updateProgress(percent) {
        this.progressFill.style.width = `${percent}%`;
        this.progressText.textContent = `Uploading... ${Math.round(percent)}%`;
    }

    renderFileList() {
        if (this.files.length === 0) {
            this.fileTableBody.innerHTML = '';
            this.emptyState.classList.remove('hidden');
            return;
        }

        this.emptyState.classList.add('hidden');
        
        // Sort files by upload date (newest first)
        const sortedFiles = [...this.files].sort((a, b) => new Date(b.uploadDate) - new Date(a.uploadDate));
        
        this.fileTableBody.innerHTML = sortedFiles.map(file => `
            <tr>
                <td data-label="Name">
                    <strong>${this.escapeHtml(file.name)}</strong>
                </td>
                <td data-label="Size">${this.formatFileSize(file.size)}</td>
                <td data-label="Type">${this.getFileTypeDisplay(file.type)}</td>
                <td data-label="Uploader">
                    <span style="color: #3b82f6; font-weight: 500;">${file.uploader || 'Anonymous'}</span>
                </td>
                <td data-label="Actions">
                    <div class="file-actions">
                        ${this.canPreview(file) ? 
                            `<button class="btn btn-outline" onclick="publicFileManager.previewFile('${file.id}')">üëÅÔ∏è Preview</button>` : 
                            ''
                        }
                        <button class="btn btn-primary" onclick="publicFileManager.downloadFile('${file.id}')">üì• Download</button>
                        <button class="btn btn-danger" onclick="publicFileManager.deleteFile('${file.id}')">üóëÔ∏è Delete</button>
                    </div>
                </td>
            </tr>
        `).join('');
    }

    canPreview(file) {
        const previewableTypes = [
            'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp',
            'application/pdf', 'text/plain'
        ];
        return previewableTypes.includes(file.type) || file.type.startsWith('image/');
    }

    previewFile(fileId) {
        const file = this.files.find(f => f.id === fileId);
        if (!file) return;

        this.modalTitle.textContent = file.name;
        this.previewContainer.innerHTML = '';

        if (file.type.startsWith('image/')) {
            if (file.data) {
                const img = document.createElement('img');
                img.src = file.data;
                img.alt = file.name;
                this.previewContainer.appendChild(img);
            } else {
                this.showPreviewError('Image not available in demo mode');
            }
        } else if (file.type === 'application/pdf') {
            if (file.data) {
                const iframe = document.createElement('iframe');
                iframe.src = file.data;
                iframe.title = file.name;
                this.previewContainer.appendChild(iframe);
            } else {
                this.showPreviewError('PDF not available in demo mode');
            }
        } else if (file.type === 'text/plain') {
            if (file.data) {
                const pre = document.createElement('pre');
                pre.style.whiteSpace = 'pre-wrap';
                pre.style.padding = '1rem';
                pre.style.background = '#f9fafb';
                pre.style.borderRadius = '8px';
                pre.style.fontSize = '0.9rem';
                pre.textContent = atob(file.data.split(',')[1]);
                this.previewContainer.appendChild(pre);
            } else {
                this.showPreviewError('Text file not available in demo mode');
            }
        } else {
            this.showPreviewError('Preview not available for this file type');
        }

        this.previewModal.classList.remove('hidden');
    }

    showPreviewError(message) {
        this.previewContainer.innerHTML = `
            <div class="preview-error">
                <p>${message}</p>
            </div>
        `;
    }

    closeModal() {
        this.previewModal.classList.add('hidden');
    }

    downloadFile(fileId) {
        const file = this.files.find(f => f.id === fileId);
        if (!file) {
            alert('‚ùå File not found!');
            return;
        }

        if (file.data) {
            const link = document.createElement('a');
            link.href = file.data;
            link.download = file.name;
            link.click();
            
            console.log(`üì• Downloaded: ${file.name}`);
        } else {
            alert('‚ùå File data not available for download');
        }
    }

    deleteFile(fileId) {
        const file = this.files.find(f => f.id === fileId);
        if (!file) return;
        
        if (confirm(`üóëÔ∏è Delete "${file.name}" from public storage?\n\n‚ö†Ô∏è This will remove it for everyone!`)) {
            this.files = this.files.filter(f => f.id !== fileId);
            this.renderFileList();
            this.savePublicFiles();
            this.updateFileCount();
            
            console.log(`üóëÔ∏è Deleted from public storage: ${file.name}`);
        }
    }

    toggleDemoMode() {
        this.isDemoMode = !this.isDemoMode;
        this.updateUI();
        
        if (this.isDemoMode) {
            this.isGoogleDriveConnected = false;
        }
    }

    async handleGoogleDrive() {
        if (this.isGoogleDriveConnected) {
            // Disconnect
            this.isGoogleDriveConnected = false;
            this.isDemoMode = true;
            this.updateUI();
        } else {
            // Connect to Google Drive
            this.showLoadingOverlay();
            
            try {
                // Simulate Google Drive connection
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // In a real implementation, you would:
                // 1. Load the Google Drive API
                // 2. Authenticate the user
                // 3. Get authorization to access their Drive
                
                this.isGoogleDriveConnected = true;
                this.isDemoMode = false;
                this.updateUI();
                
                alert('Google Drive connected successfully!\n\nNote: This is a demo. In a real implementation, you would integrate with the Google Drive API.');
            } catch (error) {
                console.error('Google Drive connection failed:', error);
                alert('Failed to connect to Google Drive');
            } finally {
                this.hideLoadingOverlay();
            }
        }
    }

    showLoadingOverlay() {
        this.loadingOverlay.classList.remove('hidden');
    }

    hideLoadingOverlay() {
        this.loadingOverlay.classList.add('hidden');
    }

    updateUI() {
        // Update button states
        this.demoModeBtn.textContent = this.isDemoMode ? 'Demo Mode (Active)' : 'Demo Mode';
        this.demoModeBtn.classList.toggle('btn-primary', this.isDemoMode);
        this.demoModeBtn.classList.toggle('btn-secondary', !this.isDemoMode);
        
        this.googleDriveBtn.textContent = this.isGoogleDriveConnected ? 
            'Disconnect Drive' : 'Connect Google Drive';
        this.googleDriveBtn.classList.toggle('btn-danger', this.isGoogleDriveConnected);
        this.googleDriveBtn.classList.toggle('btn-primary', !this.isGoogleDriveConnected);
    }

    // Utility functions
    generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    getFileTypeDisplay(mimeType) {
        if (!mimeType) return 'Unknown';
        
        const typeMap = {
            'image/jpeg': 'JPEG Image',
            'image/jpg': 'JPG Image',
            'image/png': 'PNG Image',
            'image/gif': 'GIF Image',
            'image/webp': 'WebP Image',
            'application/pdf': 'PDF Document',
            'text/plain': 'Text File',
            'text/html': 'HTML File',
            'text/css': 'CSS File',
            'text/javascript': 'JavaScript File',
            'application/json': 'JSON File',
            'application/zip': 'ZIP Archive',
            'application/x-rar-compressed': 'RAR Archive',
            'video/mp4': 'MP4 Video',
            'video/avi': 'AVI Video',
            'audio/mp3': 'MP3 Audio',
            'audio/wav': 'WAV Audio',
            'application/msword': 'Word Document',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'Word Document',
            'application/vnd.ms-excel': 'Excel Spreadsheet',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'Excel Spreadsheet'
        };

        return typeMap[mimeType] || mimeType.split('/')[1]?.toUpperCase() || 'Unknown';
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// Google Drive Integration Helper Functions
class GoogleDriveIntegration {
    constructor() {
        this.isLoaded = false;
        this.isAuthenticated = false;
        this.gapi = null;
    }

    async initialize() {
        // Load Google API script
        if (!window.gapi) {
            await this.loadScript('https://apis.google.com/js/api.js');
        }
        
        this.gapi = window.gapi;
        
        // Initialize the API
        await new Promise((resolve) => {
            this.gapi.load('client:auth2', resolve);
        });

        await this.gapi.client.init({
            apiKey: 'YOUR_API_KEY', // Replace with your API key
            clientId: 'YOUR_CLIENT_ID', // Replace with your client ID
            discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
            scope: 'https://www.googleapis.com/auth/drive.file'
        });

        this.isLoaded = true;
    }

    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    async authenticate() {
        if (!this.isLoaded) {
            await this.initialize();
        }

        const authInstance = this.gapi.auth2.getAuthInstance();
        
        if (!authInstance.isSignedIn.get()) {
            await authInstance.signIn();
        }
        
        this.isAuthenticated = true;
        return true;
    }

    async uploadFile(file) {
        if (!this.isAuthenticated) {
            throw new Error('Not authenticated with Google Drive');
        }

        const metadata = {
            name: file.name,
            parents: ['YOUR_FOLDER_ID'] // Optional: specify a folder
        };

        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
        form.append('file', file);

        const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
            method: 'POST',
            headers: new Headers({
                'Authorization': `Bearer ${this.gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token}`
            }),
            body: form
        });

        return response.json();
    }

    async listFiles() {
        if (!this.isAuthenticated) {
            throw new Error('Not authenticated with Google Drive');
        }

        const response = await this.gapi.client.drive.files.list({
            pageSize: 100,
            fields: 'nextPageToken, files(id, name, size, mimeType, createdTime)'
        });

        return response.result.files;
    }

    async downloadFile(fileId) {
        if (!this.isAuthenticated) {
            throw new Error('Not authenticated with Google Drive');
        }

        const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
            headers: {
                'Authorization': `Bearer ${this.gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token}`
            }
        });

        return response.blob();
    }

    async deleteFile(fileId) {
        if (!this.isAuthenticated) {
            throw new Error('Not authenticated with Google Drive');
        }

        await this.gapi.client.drive.files.delete({
            fileId: fileId
        });
    }
}

// Initialize the public file sharing application
let publicFileManager;

document.addEventListener('DOMContentLoaded', () => {
    publicFileManager = new PublicFileManager();
    console.log('üåê Public File Sharing Platform initialized!');
    console.log('üì¢ Anyone can upload and download files here');
});

// Export for global access (needed for onclick handlers)
window.publicFileManager = publicFileManager;
    </script>
    <script src="app.js"></script>
</body>
</html>
